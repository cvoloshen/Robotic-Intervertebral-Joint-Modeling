from xarm.wrapper import XArmAPI
import math
import time

def move_joint_flexion(arm, x_i, z_i, y_i, theta_i, theta_f, roll, yaw, steps, speed):
    # Calculate the change in angle per step (from theta_i to theta_f)
    delta_theta = theta_f/ steps

    # Store the positions to reverse the movement later
    positions = []
    positions.append((x_i, z_i,theta_i))

    for i in range(1,steps + 1):
        # Calculate the current flexion angle (starting from theta_i)
        theta = i * delta_theta

        # Calculate offsets based on the flexion angle (93 mm below TCP)
        x_offset = 93 * math.sin(math.radians(theta))
        z_offset = 93 * (math.cos(math.radians(theta)) - 1)

        x_s= x_i + x_offset
        z_s= z_i + z_offset
        theta_s= theta + theta_i
        
        # Store the position and offsets for later reversal
        positions.append((x_s, z_s, theta_s))

        # Move the arm to the new position (adding the offsets to the current position)
        print(f"Moving to step {i}: x={x_s}, y={y_i}, z={z_s}, pitch={theta_s}")
        arm.set_position(x=x_s, y=y_i, z=z_s, pitch = theta_s, roll = roll, yaw=yaw, speed=speed, wait=True)

        # Adding a small delay to ensure smooth movement
        time.sleep(0.5)

    # After the flexion/extension is complete, reverse the movement
    print("Reversing the movement to return to the starting position.")

    # Reverse the stored movements (negate offsets and angle change)
    for i in range(len(positions) - 1, -1, -1):  # Go in reverse order
        x_s, z_s, theta_s = positions[i]
        
        # Reverse the offsets and move the robot back
        print(f"Reversing to step {i}: x={x_s}, y={y_i}, z={z_s}, pitch={theta_s}")
        arm.set_position(x=x_s, y=y_i, z=z_s, pitch=theta_s,roll=roll, yaw=yaw, speed=speed, wait=True)
        
        # Adding a small delay to ensure smooth movement
        time.sleep(0.5)

def move_joint_extension(arm, x_i, z_i, y_i, theta_i, theta_f, roll, yaw, steps, speed):
    # Calculate the change in angle per step (from theta_i to theta_f)
    delta_theta = theta_f/ steps

    # Store the positions to reverse the movement later
    positions = []
    positions.append((x_i, z_i,theta_i))

    for i in range(1,steps + 1):
        # Calculate the current flexion angle (starting from theta_i)
        theta = i * delta_theta

        # Calculate offsets based on the flexion angle (93 mm below TCP)
        x_offset = -93 * math.sin(math.radians(theta))
        z_offset = 93 * (math.cos(math.radians(theta)) - 1)

        x_s= x_i + x_offset
        z_s= z_i + z_offset
        theta_s= -1*theta + theta_i
        
        # Store the position and offsets for later reversal
        positions.append((x_s, z_s, theta_s))

        # Move the arm to the new position (adding the offsets to the current position)
        print(f"Moving to step {i}: x={x_s}, y={y_i}, z={z_s}, pitch={theta_s}")
        arm.set_position(x=x_s, y=y_i, z=z_s, pitch = theta_s, roll=roll, yaw=yaw, speed=speed, wait=True)

        # Adding a small delay to ensure smooth movement
        time.sleep(0.5)

    # After the flexion/extension is complete, reverse the movement
    print("Reversing the movement to return to the starting position.")

    # Reverse the stored movements (negate offsets and angle change)
    for i in range(len(positions) - 1, -1, -1):  # Go in reverse order
        x_s, z_s, theta_s = positions[i]
        
        # Reverse the offsets and move the robot back
        print(f"Reversing to step {i}: x={x_s}, y={y_i}, z={z_s}, pitch={theta_s}")
        arm.set_position(x=x_s, y=y_i, z=z_s, pitch=theta_s, roll=roll, yaw=yaw, speed=speed, wait=True)
        
        # Adding a small delay to ensure smooth movement
        time.sleep(0.5)

# Connect to the arm
arm = XArmAPI('192.168.1.197')
arm.motion_enable(enable=True)
arm.set_mode(0)
arm.set_state(state=0)

# Get the current position of the robot (assuming pos is a tuple: (code, [x, y, z, rx, ry, rz]))
pos = arm.get_position(is_radian=False)

# Extract position values from the tuple
x_i, y_i, z_i, roll, pitch, yaw = pos[1]  # pos[1] gives the list of coordinates and angles

# Set initial flexion angle (theta_i) and final flexion angle (theta_f)
move_joint_flexion(arm, x_i=x_i, z_i=z_i, y_i=y_i, theta_i=pitch, theta_f=5, roll=roll, yaw=yaw,  steps=3, speed=30)
move_joint_extension(arm, x_i=x_i, z_i=z_i, y_i=y_i, theta_i=pitch, theta_f=5, roll=roll, yaw=yaw, steps=3, speed=30)
